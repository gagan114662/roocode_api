import { Plan, TaskResult } from '../types/project';
import { modes, ModeType } from './modes-config';
import { openaiService } from './openai-service';
import { workspaceManager } from '../core/workspace';
import { taskExecutor } from '../core/task-executor';
import { JsonValidator } from '../utils/validators';
import { fileService } from './file-service';
import path from 'path';

const DEFAULT_WORKSPACE_STRUCTURE = {
  directories: [
    'src',
    'docs',
    'tests',
    'public',
    'config'
  ],
  files: [
    {
      path: 'README.md',
      content: '# Project\n\nGenerated by RooCode\n'
    },
    {
      path: '.gitignore',
      content: `node_modules/
dist/
.env
.env.local
.cache
.DS_Store`
    }
  ]
};

export class PlanService {
  private static instance: PlanService;

  private constructor() {}

  public static getInstance(): PlanService {
    if (!PlanService.instance) {
      PlanService.instance = new PlanService();
    }
    return PlanService.instance;
  }

  public async createPlan(description: string, projectId: string): Promise<Plan> {
    try {
      // Initialize workspace first
      await workspaceManager.initializeWorkspace(projectId, DEFAULT_WORKSPACE_STRUCTURE);

      // Generate plan using PM mode
      const pmConfig = modes[ModeType.PM];
      const prompt = pmConfig.promptTemplate.replace('{{description}}', description);
      
      const completion = await openaiService.chatCompletion(prompt, true);
      if (!completion.success || !completion.data) {
        throw new Error(completion.error?.message || 'Failed to generate plan');
      }

      // Parse and validate plan
      const parsedData = JsonValidator.tryParseJson(completion.data);
      if (!parsedData.success) {
        throw new Error(`Invalid plan format: ${parsedData.error}`);
      }

      const plan = parsedData.data as Plan;
      const validationResult = JsonValidator.validatePlan(plan);
      if (!validationResult.success) {
        throw new Error(`Invalid plan structure: ${validationResult.error}`);
      }

      // Save plan to workspace
      const planPath = path.join(workspaceManager.getWorkspacePath(projectId), 'plan.json');
      const saveResult = await fileService.writeJson(planPath, plan);
      
      if (!saveResult.success) {
        throw new Error(`Failed to save plan: ${saveResult.error}`);
      }

      return plan;

    } catch (error) {
      // Clean up workspace if plan creation fails
      await workspaceManager.cleanup(projectId);
      throw error;
    }
  }

  public async executePlan(projectId: string): Promise<TaskResult[]> {
    // Validate workspace exists
    if (!await workspaceManager.validate(projectId)) {
      throw new Error('Invalid or missing workspace');
    }

    // Read and validate plan
    const planPath = path.join(workspaceManager.getWorkspacePath(projectId), 'plan.json');
    const plan = await fileService.readJson<Plan>(planPath);
    
    if (!plan) {
      throw new Error('Plan not found or invalid');
    }

    // Execute tasks
    try {
      return await taskExecutor.executeTasks(projectId, plan.tasks);
    } catch (error) {
      throw new Error(`Plan execution failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  public async getPlan(projectId: string): Promise<Plan | null> {
    const planPath = path.join(workspaceManager.getWorkspacePath(projectId), 'plan.json');
    return await fileService.readJson<Plan>(planPath);
  }

  public async cleanupProject(projectId: string): Promise<void> {
    await workspaceManager.cleanup(projectId);
  }

  public async listProjects(): Promise<string[]> {
    return await workspaceManager.listWorkspaces();
  }
}

export const planService = PlanService.getInstance();